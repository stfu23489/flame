// Custom alphabet for encoding ciphertext and signatures. Length must be 4096.
const encoderAlphabet = "聿堡摳誂逮愐瀼向餤璊衝趠蠋鈳篡肽廟孰豺廔尥軹戕齹逞疽墟蜷弟騮奸尟全鐻靠轠枋嗛縛腺嶴籋墩烘紽蠡栢眢坪魶管霿蛗葽稊砟桲掄衙曬呴瘨媾禋柜綱駱贜賵洛舅酤卮嗟辣會絍隅枑渟饙犺抒宛奚畎黕郣囫剋晻鮞糪贕夏迺崙耔蠱眇徨蜉妸牁寄啡灞頸縩鴻邅葺潤喧躁脝荇窮瓿蜣嘧霆钁寥燡希食皺傃洊潦鶚驩舺嚀旼杙鉸莖慊瘱拯呤籧呔癩輹淘蟇茨揕癱仿鏐潢萯峩拉昶齦躉捅貏膞殳塑蝔楖派彈熲銅菙颶家犨綯紅訧寤倸倏亓騖蟯棊囁鈁哄牉琨岝炊隗靦蒹狉矊輴茝别難藑蠊冱肜皇鷩菓淋甘鵌睟榛滕嚎級氊蒱奧疣瞼怎饅滓唏瘡邋蹙齯昭畝駑榻雷淙珩粉學獬益纘痱跇仇羰鞴蟆芫圓俜卹罛畷饆奢埕瀰咦銱壯厖蚨燉選禛㛂蚹呷睿碻鈃阨苴扅檎趨丏劍以蝜簜蟳蒩諞蝕僗榱杬生渺捋暌篩儇雌蟷央剨甪敧纛樿惛翽迭鑾匼淖甹緎褭懅韗酮案襵詙矻燒邑魁悽廵蠶艽閌張偉瘘返餿郎餩饕鎂眹匀瘋訥朗嵐覆觳槩菇硤際帖樑敫有羝殃反丿諦衲乩宂度媬蝀閭皎弘惌㓦遭棬室艤朏胾舂坂往葚剪韍磣攞滀馭鉺慢肅幹莝帚阻峿瓦寬值跺疚酋緅謅魭雀慵嗚劉燮蝐峋踢㥏泫啷蜈桹滵渴鯁焗衡驚蚇耄耀刀襚垺鮋涮忽欒鷫鍊琪敷薑啞岑蛑傔鬺墨蹐鯿頏苗妓財蟈熒衊艎倔露犀俛膿佾鄞鈔潁評紿髠域埛檕鄗盡縕歡鎔懆貆刻瘇容熺菠好胯朴軑滏鏘釱蟮廨齺媞麩儐樓穌昂搷沬瑑奫憧陂曰浼剉虆逍刮噍尷壽蘊鞮鼓咏嚓璐藣鵊涊芪瀾秆抄徉噗湫簣堮懁陋惶釕蠲韅踶漫穫猊愛蛋潾觔屯鍵鬫唚縫驪嫜爵鯀臆攉寂瞥欶鐧魊夊頇罭磴釿忙蛬鐇愜別呂顙順璈岐攧睆隴艮酵排伸鬯憸路宄糶堧櫜眨甩球跐莫灘膜憋佤氰坰近簀渾攪鄸醥嗿榴俇訶窄淄坶闋鋁瓓痯胖罬覼薌駪咧監豆亂迷諢拗捶賅逯檸渳魨檞顒餓剩蔪簰俚貘詫亠粱漓孴蓖瞫齖繸鉏崧叨堙毧狴瘉鏁咢踞諸擀鑀獶褖纓磲撅甃葒榕酷燐圌蟛佴忑譏佰讆簿榖虺机蔥颼醞筱吐兗浡禧嶓睩詞誣粵顑晼虱邥薊摽矽嗆韃梩玢蛓讒煉昬雒阿壩漩葄椒漂律礮狨芝輙噫直愕筧惸釷籮鍘鶴鶼阯汜銨乖忣藇諄晞笯鉢綻攔鍥冉泜嗦乣滌測晰館鐵煌槔蘄焜頍才默妢摴鸂筯落嘒瞷詻綫匵兇螲窊靜鼱訊緯甆嶪持層鞶宬屑頄逾苙墓覦柏試闒絅雖抏郢韠窋冑猿鮐蚊粗飪魋聞氘媵略嗉畏厪帢赯沂筈耋祼毖醵輾窱掭鵲狂煥礨畺螂韐綸麰傴慘飉憑諵蠖胰甋娠縟襫捺惕蟿陶媻揟礦齆徥舡嶼竊獉篥搋侁六彧馨襂車淡鏦跗世牓浣集騫穩鴷鎵襆休胂泝頭匐颿籝筭犯仙蓆楣臞妥鄰魴料翶崇咬絻塋焐卼簪濡眕藭促闕腜剔茉痀雅恢窻呫醍陵袠檖圠鱞痎槃側鷓蜎踣吮剒哷要塘莒樀鬆茴圖飰嗄搌舔窟蓀睮閛鱉虬吠滎貶飋黂儍枌邃稈驗下咈溏泖莆勻斕梢銥駛蛀鞄偏俯瘸偃瘯聾系庭呥婦琳罇桋候盛鎴疊樴踦耜沐澭擭鴽妬汞斥滷鄔驈澇嫗揍牝顠酊寯菟潑邢茪嗯笲治蔉猺需眾螌迆岡頰填廕飆伀鴾象鮟萎鷂攣例邛漚暗芎淠啥鱒蛼奭騉撽濿杏逡椰笄誏覕燼姺睦豎溉羶忍廚想閻顣協祗徭參蹬蛛轚抃焄恆聊旮窆矔皫櫌幅憊鬖鉞棐姙諤嘈菅祧銑藙月兮殯喓盎帑蘼沕造蜍驉穽劌扉懿獼鴟劇鋮艦賷抖胎娓眠緦潠疑鼃黑秩劾鑞憔騷抛韙版萹嘶葖湧讇煦忠磉樊嘕萊丌莂笏慱漠嬾術虒黿祆之玥絣聱膋腡穟縁敵二正方磬吃綎腭騀餠攭姍洋韻穉具濰舚訪鵩呆絏梗襒媺撙隼誒蒼泠尽夸婼謙驥弧脇徜搓斯衄琛疹屍穢隣斷州栳嵞堩癡嬌款筥橛玭櫂玨芧瞧灋礓蓩袞起笢次莙饟述藿咥篦漣磽挴搯膚力掯閡鬧粳俗扺噱燴鰜綅孓蕅觶殤飣熹笮雰粲頴缹鴿彔粺骷澹億娑哳睬逕鄧線曡帶嗽猍馝匣渹歸尌鄀痺畸又苳囋厝章癘熬束喘丳油囡宙漆粔第蘢釢橧蠼每嶡已裁潞蓓霉汭氆脤祡逵繜疆弭呿萴桑矬揞羨艷釆擻儱褙千餦鈞硇踁遹崆麟髩镼摸豶坼挱忨盻渭鯶癸劑霢己咍茵勞薈琚狸謂嗤諷㕒羹隊爛薏棧悰鼖瞬澀蚱蠣殈孔趲羌羽澩傭勸挑慈鞣鸝齮毯朒丕姦紫鱄繚丟閿萱汰剃屬蠵珙巡刜椿敦縪搠坏騠縠奶泚肋洺曆覬停氀韌轕鎛樺野獗遰忲碞掇糉拆柰捷齶兵門京鐙作姪琖跚輦洧戶飱牢蝓掁亡荀蜋客薛嘗骸瘍茺緇跩蝮滋緜羵堯皞葬撂豨邾瘲娉捘翦鑹嫂蹦雍郊餚犄帟侚庵籔荂賒晁頻義胠越咫削畀邂禦棷盉袂器倆忕廷邿掂廋畇埻鉒蓑枯棓檳騙睋痍瑰病封眊灄偈鶢麇黈扑吹徯恐杶頲洽碭隉駼仚子瀨刱芽痔埠氃攩鞈朾噲壠泡襭週輊䫄庣歘仗軸痏緞鐃僓撦壬膩堽鬡傒纜褯郃乏緩苞口押白譬仵眉佒嘯侮滺氿啻繮濼猩窞幄仨矧安帙擿溔膊魃攏梵機妲蠃鑣刁龠愨塭蘆銀荍佝蛞私掙鷞維慣邀撒瀟坦縝劬煩癮担檑譟焉棋涌簆挓儃技碲棰蔟靁棟糊蚤釙啣舨屭怫煜韁讜旂鰵駻遲鋪嗷箏壓鄐蟻醛忌簋骻玁斌理浞嫉晨怹塙郰悕厥燋鱓峰蟪巍樵奐笸剞婢光銹褸罽孟俾劃潸樝叒郔看鰭腍嫟閏覿啢姞欞揔備欥濩袜饔槮鈧榶絜褳嗊屩洎淟男軻也艭簺柯鍑搗麂哦慷宓謹僣庚澌錒勛㵝漲勇綪鐔駏喃曠響源胉怱袀嶮禖焚剴栗黭濇懃蒿嵩氏薠勱鬮鱧甡幺潟髶赤挺訇掔智任症卷愠耶萵纖贊嘁挃袾惑艅敶罦樅進繃償錯屈鴛狟隸鄳鄴筍樗緱廳屜誨稜墝芺敓塗舕爻趫鷸礁籑鏑息雜党綦蓏僛猫沘擗嬖刌蜼鴴璃涼模蝥猞夂姨埧棃淌靺蝠婺槿逩踸酧幸景橠賢蝻整胃嘍臺愷腮鰥岷妮窐葛軍鄲酹惎琱染扃烷坻癹炫衣綝逿哉哆秖悸柘旐搘熄僵註握虗舜邲琫胛固躊黝駍弛酒韔潰幷翹黧斶歙戳輷貓繙蟑鼴萑妗珈主部鵕榾匈懨翥衋傺漾萆冬犆畤旻罌熠戧撥予蹪溺歿廖蕾朮琇臉濕踳閞萩丸籪人稙柶竱各廄叵虀卑螅碉袡閘驄班箒酶綀它賕汸屣閾悉嚱占綟杳帤媍總闔股製赶涴傅啶偭湍鈒穗纕簽艉墻芘臯喀柧大籃畜蜇拭嘬崱嬲瑋儚陰堂欑幈而楚黴獺靂箱暖螭詄飾示蜊挹巵姌蓊戔氄罐童臝茍宦愍蛇豁倮瓅省聒巑槌穠嘏旱囑篆隙李釦榑紝攘鰣冂覶抌擩獌蘦湜絝鸛蜡澤彡滾緶菁裸繇妒拋斧姤錸鍋啅袋茆汶胦鬃券慞笆嚵禱樠鍮倗椎棨瑗獒碡煠匏岹龑翨剖脩豌夥蝦惜蚢矓並荽裻躣扠麗秧蒯礉裱懲捫纑舞盅嫋寘嘔癟莨缸儀蟄纇歗楫蜚椷癥褘娥滑懼搐汍跪旴劘麌劭抬雘鶡迹滃啵功旃崽驃畬鹺虎鑭腫艄勳蒍鷹頞鄜袄郴蜄澗婭鄣鞪戇袱簎烺鞿睗缿灺蠉氪囊犽江芬驁懻芼黜鬌黻譜遊獻勠當确徙達磾欠祇嚐教犫阱慌辞趵洚中卣摶癇滈餺嬋礌鎬縲茭峪靾瞪狳庸棜盔垔螯驏渙驂渰蹳熔曇鬍鰉顇鵃售膱折嬡鴞渚鐓鬚輛剚英詭薩洞截湖件鞵咸鼠儁完棍仞迍拴瓏憒軏讌藪德哂鰼瑁鐋焊屼操蚩呎徒沸瀍孼殑桮鏗馳繹瀋嚧斖軘鬣侞柳戍榦泌珊顱傚襞祫可溷擷袖拷疾鰹暵捃喤悌鞻核覥舸踅歷肫燭駹腌淫珞飇咽或澶曨硼杘蜮唸餉簉釓儒呪焠禡執鵜軱輐睎酌黶萰虙硎酈躲隹恌蓫蒒效杵貒鶋戹墅謬痢觸澉枕矉剜沚鰂偁杠猱飢穜俘狼淼篣邦鋒醬瑜嗣匙鰷帔屄漬褶鋰跤拿辭藺冰蝣屝即嵋仁沄荷如鳶犖巳澒狫爟彊樟陷輜眈麾氅扐廧癆冶幩烤耍悴微黨笈簸廜滮醐阬冼誤墯睄米悶屆瘓橚徹盤氙徽箠詶柵靄屁賁纀掤沓康頡探檄貊芃半絇脛喏鵀蛩擧序踡囚瞚邇愚鞃滹毗秎糴谹妐工魘嗩禚待泙塹庄謞畢襾貞苛彪司髒鄏髲皪臤鯛桐峯縱構琅蝴賦骴頯臌皰蛐酁砰避揫瘭馬菻翢氣噬拜瘕朕授堪栓濁槽掌桄筆槱殂皷澄鄇洸秋漊禁嫘鷊猲茗夜婞暹駿蘙鋋耞壟鷗旓朽颭壢阪惰涇克憹嵁鴈催巘虣幣鰻與荴蔬陴灊岧痃釾紜手硒太唶羔硭綣奏窸硯砦伋膳諆舷孱滬芚翊朔味鮨繐膘橙彛歜糙韝蕣踴蔤赭幬齕瑣蹁捏譚心駮忮冢根山嬤捵菔愴俞懌孃芩嶀硝珵帛鎡灶媢蘀彤燄氌軥習珠喌挾篘立菜剷臼甔礎喝怢翎悟昳捍鶊瓶訏璅遳妖溼堠洭丞穀駘媚棄蕺唅覽遑曀澂厓簠鰮茌紒邐翟蕎隱鞓籺瘦跆聝侜泓救濛陡饌螳藋繒楯鏃熯較倫缽槍茇戴聶秠胵蘠臘軼侶脡泣襌厜嗾瞽鬉衛渥騸蚳亍麈閫擋尬垕怭囅荸岋僆稾厠惵擦奉暍鞨渡籛啓扂瘞酉瑟澦偊嘓魑綌鴒受妺鎢畽瞟茄營宎創員窪蛾壞韡遡麯屐醋妃藂頗豉吋冠笨踊苾襤獅蒟袈刨侹搰趴攠嫮獠菆醫齔嬴炔鯠馞饝窿拫庌斫弰鵁詘歉箴姓殉點傍倜衽區牌幰譔悃衮跴齵漁瑾繩妎未鉶鷧蒞曾掘冲冥覯鈮屘仲籲盦鬭佺灼雙垣遂轎夬浮駓緧蜌黰提汪斗恰娜洴鏵蔏瑪汾糸傀摯漳痤蟀荵靼驎蘧鱇鸏赸謄磔筠糯蛟醇杇苕泪櫺摃睨凍實游懋懸旎癬壎扛睅迪俏岳麀陏喟趾划遇綉舒歑饊港鐺侲垃剫鵮鍳快開筳蕙飀號撆醓蹅喳蜓淹凋寇礴結曲鍠署斡新个掆拼鷕投蚌鑿爝札憱弃橑筢裟炕攛襢鱍虩禨偟糱煽齾汆皮錧悍擢穎岵脹佯眯艱蕡茼雥儴牸脢旗聯蜯腳付蝃鷖錠璵嶰庫崖皋倓繕噔嚄聖蜢妯槬勢潏构傜欄閎磁髏割劓搜齏憎薪津晜掞捭貲癃匽倭崓圇柣恂怩邱負簑銛争訛孤茬瓖郼寃脆汏懶髂憨卿斨改鰈蝖鯷睢唧躡搨蹧攖籉犁胥嚮痝雁詿餟歧幢蝙圭饜瀆莕樁險馥短姊琴十俎鵡骯鷲捆弗魈笐颱醊脧鯪毡圃圾糜乂蓋邪鋣碏厔魦絿廬印姻侔薙鸑僭幞媮靶譖成的鮎蛣倦荑硜燠砒嗡椹讙檛絛杼璲餑扆漵膺岩舌雝餵戌悢鉕庋倞鞾拐八振絕萐戩彠鏹羆蠁楸于箜觴酯繳哿枷噉恿殜炤缺偕騂濆虫假濘崔擅荎醚烙墜疙熳庀彼汎愎唫咿枇淰板蛤䥈肉鞚縴漿混剮嶁曷傌搎媱副蠏鰾菂憖坡卅倘索鈑轖齇垗荓鄍襠倡甎侃藐譴矎暇池役橜饉朦潎戀傖梒搳帽笫闐蹞菡怐煙噩芍甑襖砫踐斑飁因凇葍嗌浹嫕扯得做贗壜挈撫塼叱哰辨膍麴羿籓磺仟踱赩糖疔甭寒條茳語侑鰿慍匴箍腔㲪嗔用蔚瑒桀綢慫崡賄鉛柬賚墠裳偩鉚碴勒唲餘珏襡椗咷吪艓蹕褽僉酅灰皖籟愣鰕鄉葶咪吩鶩蘾吶懺經瀇隩柚鏈颯幟邽胔摠搏危囝眶慲躩忖嗈靆螈蹩巿夨撈婿倉砆浪蕊麄閶愊黛鄹忤㶁萬尉莔餪鷟涎訞玼躠壝蒴鍭蒨干忿肓欝盭磌曦淚領猶藤鮅籐僑殖棹姹礩軒曅茫粟卌毫票噙斀脬榣兒揣栔臅止觖瓌廥氯甍猋穰足窩褫偷猒嗑數橫縓絆泬䰐湝啤藳狶揄沿莉鈍鍺恒柴蕑錆映蓳鍍紀霄譾鱠礽褔練梲襃朣鯗叶摻鼒髫殞磈紺幻睃爊櫃毾尺匄毬諗疿櫰琰溚宋馹罳髖蜞襜証逗閬遠蔔霏櫱拑騬自唈芸馴玈盒牿灝蛁膃迤梧叡利郁錐仄衎饛筏殗枴撰嘹蝳咡匸菽鷥喪堞羱跧䰰剄蹮斝怛詆類刄妍耆嚙妙攟啁裒王庇爸竪鏙彷袷姿逝玉縉謾霹帣鍉瑊諳洲翀毛輅陀淴爾耨斤盂鮑漅囮賫珂錮訄筊囃軺喲唔嫭嘑鍔漉長訝雇儿粢飜符型稍裴猴話島湮蟭儘靈比鉗玠肕嗥貾攙嚆澍披遜薺湅咱捻耗婬筷沙躋皂缾輓薶釔葦愓圈瓞燥孺憲鯓孿胹凑煻渠拽汊辜壕艴曳吧凹唓囿琭尻麕櫫紡永毆儈軬表豊廛囷穛醭鷾許爁繅牲殿紱鸜吆斜暈釣臿疲黲鄢鐳宿褻鱖麃靮吷泰謦覊愁庳嚷胏皴羢簷憙朝咨筤墀槁怍屹跬猝蠔狺襣鑢貍躑畔冣鳳蹇侗驦龐傲饡拔黯照三瓬炘鑵誇貫鴣肭誆矐醮蔧鬴床蜂估鄯轒綑姘瘤昵恝莊再箋午他鄱攕㲯犵緊聰齚卲榭唁酇稰吵賡檗箎嗓戤吁蚕瞞黽抉蓽謟蔇誻狄閈腤箝鬑膈睠儩神齜瑀狹閹穅絡斛晾礄駟頵灖噶猛磞僔窒箐瞤箇怖書餫柅湛消柱遍湉迨阜洿交讖甲篠剕稀西閟坌噆琍敻鱣妁獸鹽廊鯇嘟悝辰縋羋覡蒙崐兢郿琦犛銍嬸屢礙磨嘲寡牆苔榆緡琶殙韘鍅碟欺攜沏沷竭垌韂騏蝤囉瘳喻洄躍佌悛嚼棚睏推菌堁殀齒埌唳簙勖商艸秕紆斁倀閧嚾登肱巒溠蜙戄巹臠賈聽摝絎胇栙倨址斸訢專偯腹蘘爓躂蚶迄身釅溜皜幎溘呸年宀咚溫鍬啼昜采鏤腕邡郡請搭急嫥矁醟鐎鶺麥蜤同胱俶篁貽穈鱻庮樹惆櫟損睺搛覜塓璠鼎婥聲福眩揉傷霙睡碔曛云葟烴惘悻龤搡歹鮦扮鋌娩酐紩澣苦砵敔嬝渲蚿醡擫咵郫鏮痠禪釂裌膷蠓疒轍湱夢姏牋倬轝蜘意獮唬馯袛腸偺友唗傘少算虛連蟶暠遽郝蕤鄘飡煢夲赬謊誥蹜炯鴃顓棉囂眡瘣戭峙篚竑"

import { MlKem768 } from "https://esm.sh/mlkem";
import pqcSignFalcon512 from "https://cdn.jsdelivr.net/npm/@dashlane/pqc-sign-falcon-512-browser@1.0.0/dist/pqc-sign-falcon-512.min.js";

const _standardBase64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const _standardCharToInt = (() => {
  const map = {};
  for (let i = 0; i < _standardBase64Chars.length; i++) {
    map[_standardBase64Chars[i]] = i;
  }
  return map;
})();

function encodeBase64ToCustom(base64String, customAlphabet) {
  if (customAlphabet.length !== 4096) {
    console.warn(`warning: custom alphabet length is ${customAlphabet.length}, expected 4096`);
  }

  const cleanBase64String = base64String.replace(/=+$/, '');
  const mappedResult = [];

  for (let i = 0; i < cleanBase64String.length; i += 2) {
    if (i + 1 < cleanBase64String.length) {
      const value1 = _standardCharToInt[cleanBase64String[i]];
      const value2 = _standardCharToInt[cleanBase64String[i + 1]];
      if (value1 === undefined || value2 === undefined) continue;
      const combined12BitValue = (value1 << 6) | value2;
      mappedResult.push(customAlphabet[combined12BitValue]);
    } else {
      mappedResult.push(cleanBase64String[i]);
    }
  }

  return mappedResult.join("");
}

function decodeCustomToBase64(mappedString, customAlphabet) {
  if (customAlphabet.length !== 4096) {
    console.warn(`warning: custom alphabet length is ${customAlphabet.length}, expected 4096`);
  }

  const customCharToInt = {};
  for (let i = 0; i < customAlphabet.length; i++) {
    customCharToInt[customAlphabet[i]] = i;
  }

  const decoded = [];

  for (const char of mappedString) {
    const val = customCharToInt[char];
    if (val === undefined) {
      if (_standardCharToInt[char] !== undefined) decoded.push(char);
      continue;
    }
    const v1 = (val >> 6) & 0x3F;
    const v2 = val & 0x3F;
    decoded.push(_standardBase64Chars[v1], _standardBase64Chars[v2]);
  }

  while (decoded.length % 4 !== 0) decoded.push('=');
  return decoded.join('');
}

const toBase64 = u8 => btoa(String.fromCharCode(...u8));
const fromBase64 = s => { try { return new Uint8Array(atob(s).split('').map(c => c.charCodeAt(0))); } catch { return null; } };

async function compressString(str) {
  const stream = new CompressionStream('gzip');
  const writer = stream.writable.getWriter();
  writer.write(new TextEncoder().encode(str));
  writer.close();
  const chunks = [];
  const reader = stream.readable.getReader();
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    chunks.push(value);
  }
  return toBase64(new Uint8Array(await new Blob(chunks).arrayBuffer()));
}

async function decompressString(base64Str) {
  const data = fromBase64(base64Str);
  if (!data) return null;
  const stream = new DecompressionStream('gzip');
  const writer = stream.writable.getWriter();
  writer.write(data);
  writer.close();
  const chunks = [];
  const reader = stream.readable.getReader();
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    chunks.push(value);
  }
  return new TextDecoder().decode(await new Blob(chunks).arrayBuffer());
}

// DOM Elements
const genKeysBtn = document.getElementById('genKeysBtn');
const yourPub = document.getElementById('yourPublicKey');
const yourPriv = document.getElementById('yourPrivateKey');
const impExp = document.getElementById('importExportKeys');
const importBtn = document.getElementById('importKeysBtn');
const exportBtn = document.getElementById('exportKeysBtn');
const recPub = document.getElementById('recipientPublicKey');
const inp = document.getElementById('inputText');
const encBtn = document.getElementById('encryptSignBtn');
const decBtn = document.getElementById('decryptVerifyBtn');
const out = document.getElementById('outputText');
const res = document.getElementById('verifyResult');
const alertPopup = document.getElementById('alertPopup');
const alertMessage = document.getElementById('alertMessage');
const alertProgressBar = document.getElementById('alertProgressBar');

// State
let kem, falcon, mlkemPub, mlkemPriv, faPub, faPriv;

function showAlert(message, isError = false) {
  alertMessage.textContent = message.toLowerCase();
  alertPopup.classList.remove('alert-success', 'alert-error');
  alertPopup.classList.add(isError ? 'alert-error' : 'alert-success');
  alertPopup.classList.add('show');

  alertProgressBar.style.animation = 'none';
  void alertProgressBar.offsetWidth;
  alertProgressBar.style.animation = null;

  setTimeout(() => alertPopup.classList.remove('show'), 3000);
}

function clearOutput() {
  out.value = "";
  res.textContent = "";
}

// Generate Keypairs
genKeysBtn.addEventListener('click', async () => {
  genKeysBtn.disabled = true;
  genKeysBtn.textContent = "generating...";
  try {
    kem = new MlKem768();
    [mlkemPub, mlkemPriv] = await kem.generateKeyPair();
    falcon = await pqcSignFalcon512();
    const fk = await falcon.keypair();
    faPub = fk.publicKey;
    faPriv = fk.privateKey;

    const mlkemPubCustom = encodeBase64ToCustom(toBase64(mlkemPub), encoderAlphabet);
    const mlkemPrivCustom = encodeBase64ToCustom(toBase64(mlkemPriv), encoderAlphabet);
    const faPubCustom = encodeBase64ToCustom(toBase64(faPub), encoderAlphabet);
    const faPrivCustom = encodeBase64ToCustom(toBase64(faPriv), encoderAlphabet);

    yourPub.value = `${mlkemPubCustom}|${faPubCustom}`;
    yourPriv.value = `${mlkemPrivCustom}|${faPrivCustom}`;
    
    showAlert("keypairs generated successfully");
  } catch (e) {
    showAlert("key generation failed", true);
    console.error(e);
  } finally {
    genKeysBtn.disabled = false;
    genKeysBtn.textContent = "generate your keypairs (mlkem + falcon)";
    clearOutput();
  }
});

// Export Keys
exportBtn.addEventListener('click', async () => {
  if (!mlkemPub || !faPub || !mlkemPriv || !faPriv) return showAlert("generate or import keys first", true);
  try {
    const [mlkemPubCustom, faPubCustom] = yourPub.value.split("|");
    const [mlkemPrivCustom, faPrivCustom] = yourPriv.value.split("|");

    const mlkemPubBase64 = decodeCustomToBase64(mlkemPubCustom, encoderAlphabet);
    const faPubBase64 = decodeCustomToBase64(faPubCustom, encoderAlphabet);
    const mlkemPrivBase64 = decodeCustomToBase64(mlkemPrivCustom, encoderAlphabet);
    const faPrivBase64 = decodeCustomToBase64(faPrivCustom, encoderAlphabet);
    
    const rawKeys = JSON.stringify({
      mlkemPub: mlkemPubBase64,
      faPub: faPubBase64,
      mlkemPriv: mlkemPrivBase64,
      faPriv: faPrivBase64,
    });
    impExp.value = await compressString(rawKeys);
    showAlert("keys exported and compressed");
  } catch (e) {
    showAlert("export failed", true);
    console.error(e);
  }
});

// Import Keys
importBtn.addEventListener('click', async () => {
  const compressedData = impExp.value.trim();
  if (!compressedData) return showAlert("paste key data first", true);
  try {
    const decompressed = await decompressString(compressedData);
    if (!decompressed) return showAlert("decompression failed", true);

    const keys = JSON.parse(decompressed);
    mlkemPub = fromBase64(keys.mlkemPub);
    faPub = fromBase64(keys.faPub);
    mlkemPriv = fromBase64(keys.mlkemPriv);
    faPriv = fromBase64(keys.faPriv);

    const mlkemPubCustom = encodeBase64ToCustom(keys.mlkemPub, encoderAlphabet);
    const faPubCustom = encodeBase64ToCustom(keys.faPub, encoderAlphabet);
    const mlkemPrivCustom = encodeBase64ToCustom(keys.mlkemPriv, encoderAlphabet);
    const faPrivCustom = encodeBase64ToCustom(keys.faPriv, encoderAlphabet);

    yourPub.value = `${mlkemPubCustom}|${faPubCustom}`;
    yourPriv.value = `${mlkemPrivCustom}|${faPrivCustom}`;
    
    showAlert("keys imported successfully");
    clearOutput();
  } catch (e) {
    showAlert("import failed", true);
    console.error(e);
  }
});

// Encrypt & Sign
encBtn.addEventListener('click', async () => {
  clearOutput();
  const msg = inp.value.trim();
  const rec = recPub.value.trim();
  if (!msg || !rec) return showAlert("message and recipient key required", true);

  const [rkpStrCustom, rfpStrCustom] = rec.split("|");
  const rkpStr = decodeCustomToBase64(rkpStrCustom, encoderAlphabet);
  const rfpStr = decodeCustomToBase64(rfpStrCustom, encoderAlphabet);

  const rkp = fromBase64(rkpStr);
  const rfp = fromBase64(rfpStr);
  if (!rkp || !rfp) return showAlert("invalid recipient keys", true);

  try {
    if (!kem) kem = new MlKem768();
    const [ctMLKem, shared] = await kem.encap(rkp);

    if (!falcon) falcon = await pqcSignFalcon512();
    const signature = (await falcon.sign(new TextEncoder().encode(msg), faPriv)).signature;

    const payload = JSON.stringify({ m: msg, s: toBase64(signature) });
    const compressed = await compressString(payload);
    const compressedBytes = fromBase64(compressed);

    const aesKey = await crypto.subtle.importKey("raw", shared, "AES-GCM", false, ["encrypt"]);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, compressedBytes));

    const encoded = [
      encodeBase64ToCustom(toBase64(ctMLKem), encoderAlphabet),
      encodeBase64ToCustom(toBase64(iv), encoderAlphabet),
      encodeBase64ToCustom(toBase64(ciphertext), encoderAlphabet)
    ].join("|");

    out.value = encoded;
    showAlert("encryption & signing complete");
  } catch (e) {
    showAlert("encryption failed", true);
    console.error(e);
  }
});

// Decrypt & Verify
decBtn.addEventListener('click', async () => {
  clearOutput();
  const val = inp.value.trim();
  if (!val) return showAlert("enter encrypted input", true);

  const [privMLCustom, privFACustom] = yourPriv.value.trim().split("|");
  const [pubMLCustom, pubFACustom] = recPub.value.trim().split("|");
  
  const privML = decodeCustomToBase64(privMLCustom, encoderAlphabet);
  const privFA = decodeCustomToBase64(privFACustom, encoderAlphabet);
  const pubFA = decodeCustomToBase64(pubFACustom, encoderAlphabet);
  
  const sK = fromBase64(privML);
  const sF = fromBase64(privFA);
  const pF = fromBase64(pubFA);

  if (!sK || !sF || !pF) return showAlert("invalid or missing keys", true);

  const parts = val.split("|");
  if (parts.length !== 3) return showAlert("incorrect input format", true);

  const [ctK, ivStr, ctStr] = parts.map(p => fromBase64(decodeCustomToBase64(p, encoderAlphabet)));
  if (!ctK || !ivStr || !ctStr) return showAlert("invalid encoded data", true);

  try {
    if (!kem) kem = new MlKem768();
    const shared = await kem.decap(ctK, sK);
    const aesKey = await crypto.subtle.importKey("raw", shared, "AES-GCM", false, ["decrypt"]);

    const decrypted = new Uint8Array(await crypto.subtle.decrypt({ name: "AES-GCM", iv: ivStr }, aesKey, ctStr));
    const decompressed = await decompressString(toBase64(decrypted));
    const { m, s } = JSON.parse(decompressed);

    if (!m || !s) return showAlert("missing message or signature", true);

    if (!falcon) falcon = await pqcSignFalcon512();
    const valid = await falcon.verify(fromBase64(s), new TextEncoder().encode(m), pF);

    out.value = m;
    valid ? (res.textContent = "✅ signature is valid", res.style.color = "#90ee90") 
      : (res.textContent = "❌ signature is invalid", res.style.color = "#f08080");

    showAlert("decryption & verification complete");
  } catch (e) {
    showAlert("decryption or verification failed", true);
    console.error(e);
  }
});

// Tabs
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const tgt = btn.getAttribute('data-tab');
    document.querySelectorAll('.tab-content').forEach(sec => {
      sec.classList.toggle('hidden', sec.id !== tgt);
    });
  });
});
